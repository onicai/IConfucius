#!/usr/bin/env python3
"""Fetch top bonded tokens from Odin.fun and update tokens.toml.

Run periodically to keep the shipped token registry current:

    python scripts/update_tokens.py

Writes the top 20 bonded tokens by volume, with ICONFUCIUS (29m8) always first.

Odin.fun API notes:
- /v1/tokens supports limit (max 100) and page (1-indexed)
- No server-side bonded filter — must paginate and filter client-side
- Sorting by volume:desc puts bonded tokens first
"""

import datetime
import sys
from pathlib import Path

from curl_cffi import requests

API_BASE = "https://api.odin.fun/v1"
OUTPUT_PATH = Path(__file__).resolve().parent.parent / "src" / "iconfucius" / "tokens.toml"

# ICONFUCIUS is always the first token in the registry
ICONFUCIUS_ID = "29m8"

# How many tokens to keep in the registry
TOP_N = 20

# Pagination
PAGE_LIMIT = 100
MAX_PAGES = 10  # 10 pages × 100 = 1000 tokens scanned, plenty for top 20


def fetch_bonded_tokens() -> list[dict]:
    """Fetch bonded tokens from the Odin.fun API (sorted by volume desc)."""
    bonded: list[dict] = []
    consecutive_empty = 0
    page = 1

    while page <= MAX_PAGES:
        resp = requests.get(
            f"{API_BASE}/tokens",
            params={"limit": PAGE_LIMIT, "sort": "volume:desc", "page": page},
            impersonate="chrome",
            headers={"Accept": "application/json"},
            timeout=15,
        )
        resp.raise_for_status()
        data = resp.json()
        tokens = data.get("data", [])

        if not tokens:
            break

        page_bonded = [t for t in tokens if t.get("bonded") is True]
        bonded.extend(page_bonded)

        n_bonded = len(page_bonded)
        print(f"  page {page:3d}: {n_bonded:3d} bonded / {len(tokens)} tokens  (total: {len(bonded)})")

        # We have enough bonded tokens once we have TOP_N + 1 (ICONFUCIUS may
        # or may not be in the top N by volume)
        if len(bonded) >= TOP_N + 1:
            break

        if n_bonded == 0:
            consecutive_empty += 1
            if consecutive_empty >= 2:
                break
        else:
            consecutive_empty = 0

        page += 1

    return bonded


def select_top_tokens(bonded: list[dict]) -> list[dict]:
    """Pick top TOP_N tokens: ICONFUCIUS first, then highest volume."""
    # Separate ICONFUCIUS from the rest
    iconfucius = None
    others = []
    for t in bonded:
        if t["id"] == ICONFUCIUS_ID:
            iconfucius = t
        else:
            others.append(t)

    if iconfucius is None:
        # Fetch ICONFUCIUS directly if not in the volume-sorted pages
        print(f"  Fetching ICONFUCIUS ({ICONFUCIUS_ID}) directly...")
        resp = requests.get(
            f"{API_BASE}/token/{ICONFUCIUS_ID}",
            impersonate="chrome",
            headers={"Accept": "application/json"},
            timeout=15,
        )
        resp.raise_for_status()
        iconfucius = resp.json()

    # others are already sorted by volume desc from the API
    top_others = others[:TOP_N - 1]

    return [iconfucius] + top_others


def write_toml(tokens: list[dict]) -> None:
    """Write tokens to TOML file. ICONFUCIUS first, rest sorted by token ID."""
    today = datetime.date.today().isoformat()

    # Keep ICONFUCIUS first, sort the rest by token ID for stable diffs
    first = tokens[0]
    rest = sorted(tokens[1:], key=lambda t: t["id"])
    ordered = [first] + rest

    lines = [
        f"# Top {len(ordered)} bonded tokens on Odin.fun — auto-generated by scripts/update_tokens.py",
        f"# Last updated: {today}",
        f"#",
        f"# ICONFUCIUS (29m8) is always listed first",
        f"# Remaining tokens sorted by token ID",
        f"# Token IDs are the primary key (unique on Odin.fun)",
        f"# Names and tickers are NOT unique — always use the token ID",
        f"# Marketcap is a snapshot used for disambiguation (bonded + highest marketcap wins)",
        f"",
    ]

    for t in ordered:
        token_id = t["id"]
        name = t.get("name", "").replace('"', '\\"')
        ticker = t.get("ticker", "").replace('"', '\\"')
        marketcap = t.get("marketcap", 0)
        holder_count = t.get("holder_count", 0)
        bonded = t.get("bonded", False)
        twitter_verified = t.get("twitter_verified", False)
        created_time = t.get("created_time", "")

        lines.append(f"[tokens.{token_id}]")
        lines.append(f'name = "{name}"')
        lines.append(f'ticker = "{ticker}"')
        lines.append(f"marketcap = {marketcap}")
        lines.append(f'marketcap_date = "{today}"')
        lines.append(f"holder_count = {holder_count}")
        lines.append(f"bonded = {'true' if bonded else 'false'}")
        lines.append(f"twitter_verified = {'true' if twitter_verified else 'false'}")
        lines.append(f'created_time = "{created_time}"')
        lines.append("")

    OUTPUT_PATH.write_text("\n".join(lines))


def main() -> None:
    print(f"Fetching top {TOP_N} bonded tokens from {API_BASE}...")

    bonded = fetch_bonded_tokens()
    if not bonded:
        print("ERROR: No bonded tokens found. API may be down.", file=sys.stderr)
        sys.exit(1)

    tokens = select_top_tokens(bonded)

    write_toml(tokens)

    print(f"\nWrote {len(tokens)} tokens to {OUTPUT_PATH}")
    print(f"  First: {tokens[0].get('name', '')} ({tokens[0]['id']})")


if __name__ == "__main__":
    main()
